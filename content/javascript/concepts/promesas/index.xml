<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Promesas on Book</title><link>https://rick-torrellas.github.io/book__a/content/javascript/concepts/promesas/</link><description>Recent content in Promesas on Book</description><generator>Hugo -- gohugo.io</generator><language>es</language><lastBuildDate>Wed, 28 Sep 2022 19:17:00 +0000</lastBuildDate><atom:link href="https://rick-torrellas.github.io/book__a/content/javascript/concepts/promesas/index.xml" rel="self" type="application/rss+xml"/><item><title/><link>https://rick-torrellas.github.io/book__a/content/javascript/concepts/promesas/async-await/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://rick-torrellas.github.io/book__a/content/javascript/concepts/promesas/async-await/</guid><description>async/await Como usar aync/await con una promesa?
function pepe() { return new Promise(function(resolve, reject) { setTimeout(() =&amp;gt; { console.log(&amp;#39;Primera cadena de promesas&amp;#39;); resolve(1) }, 3000); // (*) }).then(function(result) { // (**) console.log(result); // 1 return result * 2; }) } async function nani(){ await pepe() }; nani(); o
const pepe = new Promise(function(resolve, reject) { setTimeout(() =&amp;gt; { console.log(&amp;#39;Primera cadena de promesas&amp;#39;); resolve(1) }, 3000); // (*) }).then(function(result) { // (**) console.</description></item><item><title/><link>https://rick-torrellas.github.io/book__a/content/javascript/concepts/promesas/basic/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://rick-torrellas.github.io/book__a/content/javascript/concepts/promesas/basic/</guid><description>Basic Para ejecutar una promesa
a .then(res =&amp;gt; { console.log(`Success: ${res}`) }) .catch(error =&amp;gt; { console.log(`Error: ${error}`) }) Se usa then para ejecutar una funcion si la operacion es exitosa y catch para ejecutar una accion en caso de que exista un error.
Funcion normal se puede ejecutar una promesa dentro de una funcion normal
function cara() { const resultado = &amp;#39;VALOR&amp;#39;; return new Promise((a,b)=&amp;gt; { a(resultado); }) } function normal() { cara() .</description></item><item><title/><link>https://rick-torrellas.github.io/book__a/content/javascript/concepts/promesas/commond-mistakes/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://rick-torrellas.github.io/book__a/content/javascript/concepts/promesas/commond-mistakes/</guid><description>commond mistakes // ¡Mal ejemplo! hacerlAlgo().then(function(resultado) { hacerOtraCosa(resultado) // Olvida devolver una promesa desde el interior de la cadena + anidamiento innecesario .then(nuevoResultado =&amp;gt; hacerUnaTerceraCosa(nuevoResultado)); }).then(() =&amp;gt; hacerUnaCuartaCosa()); // Olvida terminar la cadena con un catch! deferred antipattern
function getStuffDone(param) { return new Promise(function(resolve, reject) { myPromiseFn(param+1) .then(function(val) { resolve(val); }).catch(function(err) { reject(err); }); }); } no encadenar las acciones adecuadamente. Esto sucede cuando creamos una promesa y olvidamos devolverla. Como consecuencia, la cadena se rompe, o mejor dicho, tenemos dos cadenas independientes que compiten.</description></item><item><title/><link>https://rick-torrellas.github.io/book__a/content/javascript/concepts/promesas/ejemplos/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://rick-torrellas.github.io/book__a/content/javascript/concepts/promesas/ejemplos/</guid><description>Ejemplos Primer const a = id =&amp;gt; { return new Promise((resolve,reject)=&amp;gt;{ if(x == 10) { resolve(&amp;#39;Correcto&amp;#39;) } else { reject(&amp;#39;Incorrecto&amp;#39;); } }); }; a(23) .then(resultado=&amp;gt;{ console.log(resultado); })</description></item><item><title/><link>https://rick-torrellas.github.io/book__a/content/javascript/concepts/promesas/encadenado/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://rick-torrellas.github.io/book__a/content/javascript/concepts/promesas/encadenado/</guid><description>Encadenado Encadenar cadenas de promesas xample 1 - basic const promise = new Promise(function(resolve, reject) { setTimeout(() =&amp;gt; { console.log(&amp;#39;Primera cadena de promesas&amp;#39;); resolve(1) }, 1000); // (*) }) .then(function(result) { // (**) console.log(result); // 1 return result * 2; }) .then(res=&amp;gt; { console.log(res); return res*2 }) .catch(err =&amp;gt; { console.log(err); }); const promise2 = promise .then(result =&amp;gt; { console.log(&amp;#39;segunda cadena de promesas&amp;#39;); console.log(result); // 4 return result * 2; }) .</description></item><item><title/><link>https://rick-torrellas.github.io/book__a/content/javascript/concepts/promesas/promise-callback/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://rick-torrellas.github.io/book__a/content/javascript/concepts/promesas/promise-callback/</guid><description>Usar promise con callback fs.readFile new Promise(function (resolve, reject) { fs.readFile(&amp;#39;myfile.txt&amp;#39;, function (err, file) { if (err) { return reject(err); } resolve(file); }); }).then(/* ... */)</description></item><item><title/><link>https://rick-torrellas.github.io/book__a/content/javascript/concepts/promesas/then/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://rick-torrellas.github.io/book__a/content/javascript/concepts/promesas/then/</guid><description>Then Que se puede hacer dentro de un then?
Nota: creo que la respuesta no tiene que usarse ajuro, en el siguiente return. Pero si debes retornar algo ajuro.
Nota:
return another promise function promesa() { const valor = &amp;#39;ramon&amp;#39;; return new Promise((ar,er) =&amp;gt; { ar(valor); }) } function otraPromesa(value) { const valor = `${value}!!!!!!`; return new Promise((ar,er) =&amp;gt; { if (valor == undefined) { er(); } ar(valor.toUpperCase()); }) } promesa() .</description></item></channel></rss>